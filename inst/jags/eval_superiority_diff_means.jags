model{
  for (k in 1:n_arms) {
    for (i in 1:n[k]) {
      Y[i,k] ~ dnorm(mu[k], tau[k])
    }

    mu[k] ~ dnorm(0, 0.001)
    tau[k] ~ dgamma(0.001, 0.001)
    sigma[k] <- 1 / sqrt(tau[k])  # Convert precision to standard deviation

    # Calculate observed means
    obs_mean[k] <- mean(Y[1:n[k],k])
    obs_sd[k] <- sd(Y[1:n[k],k])
  }

  for (k in 2:n_arms) {
    # Estimate the treatment effect
    trteff[k] <- mu[k] - mu[1]

    # Predict the mean difference in future data (only relevant if Y contains missing values)
    obs_diff[k] <- obs_mean[k] - obs_mean[1]

    # Calculate pooled variance
    # See https://www.math.chalmers.se/Stat/Grundutb/GU/MSA620/S20/Assurance.pdf
    sigma_pooled[k] <- sqrt(sigma[k]**2/n[k] + sigma[1]**2/n[1])
    sd_pooled[k] <- sqrt(obs_sd[k]**2/n[k] + obs_sd[1]**2/n[1])

    # Calculate assurance for the observed Y
    R[k] <- mu[k]-mu[1] > sigma_pooled[k]*z_alpha

    # Calculate assurance for observed & future Y
    R_pred[k] <- obs_diff[k] > sd_pooled[k]*z_alpha
  }
}

